# Manuel d'Exploitation - Système de Contrôle Ornithoptère
**Version 1.0 - Août 2025**

## Sommaire

- [Manuel d'Exploitation - Système de Contrôle Ornithoptère](#manuel-dexploitation---système-de-contrôle-ornithoptère)
  - [Sommaire](#sommaire)
  - [1. Procédures opérationnelles](#1-procédures-opérationnelles)
    - [1.1 Démarrage du système](#11-démarrage-du-système)
      - [1.1.1 Allumage](#111-allumage)
    - [1.2 Utilisation normale](#12-utilisation-normale)
      - [1.2.1 Contrôles de base](#121-contrôles-de-base)
      - [1.2.2 Fonctionnement normal](#122-fonctionnement-normal)
    - [1.3 Arrêt du système](#13-arrêt-du-système)
      - [1.3.1 Arrêt normal](#131-arrêt-normal)
      - [1.3.2 Arrêt d'urgence](#132-arrêt-durgence)
  - [2. Vue d'ensemble du système](#2-vue-densemble-du-système)
    - [2.1 Description du produit logiciel](#21-description-du-produit-logiciel)
    - [2.2 Architecture système](#22-architecture-système)
    - [2.3 Contexte opérationnel client](#23-contexte-opérationnel-client)
  - [3. Caractéristiques quantitatives du système](#3-caractéristiques-quantitatives-du-système)
    - [3.1 Données de performance CPU et Mémoire](#31-données-de-performance-cpu-et-mémoire)
      - [3.1.1 ESP32 (Environnement de production)](#311-esp32-environnement-de-production)
    - [3.2 Volume des données traitées](#32-volume-des-données-traitées)
      - [3.2.1 Communication radio (NRF24L01)](#321-communication-radio-nrf24l01)
      - [3.2.2 Volumes par période](#322-volumes-par-période)
    - [3.3 Performances temps réel](#33-performances-temps-réel)
  - [4. Description des processus et interactions](#4-description-des-processus-et-interactions)
    - [4.1 Processus Émetteur (`emetteur_esp32.py`)](#41-processus-émetteur-emetteur_esp32py)
      - [4.1.1 Responsabilités](#411-responsabilités)
      - [4.1.2 Interactions externes](#412-interactions-externes)
      - [4.1.3 Flux de données](#413-flux-de-données)
    - [4.2 Processus Récepteur (`recepteur_esp32.py`)](#42-processus-récepteur-recepteur_esp32py)
      - [4.2.1 Responsabilités](#421-responsabilités)
      - [4.2.2 Interactions externes](#422-interactions-externes)
      - [4.2.3 Flux de données](#423-flux-de-données)
    - [4.3 Communication Inter-Processus](#43-communication-inter-processus)
      - [4.3.1 Mode Production (ESP32)](#431-mode-production-esp32)
  - [5. Dépannage et diagnostic](#5-dépannage-et-diagnostic)
    - [5.1 Problèmes de communication](#51-problèmes-de-communication)
    - [5.2 Problèmes de performance](#52-problèmes-de-performance)
  - [6. Sécurité et limites](#6-sécurité-et-limites)
    - [6.1 Limites opérationnelles](#61-limites-opérationnelles)
    - [6.2 Procédures de sécurité](#62-procédures-de-sécurité)
  - [7. Mises à jour](#7-mises-à-jour)
    - [7.1 Notification des nouvelles versions](#71-notification-des-nouvelles-versions)
      - [7.1.1 Recevoir les notifications automatiquement](#711-recevoir-les-notifications-automatiquement)
    - [7.2 Procédure de mise à jour simplifiée](#72-procédure-de-mise-à-jour-simplifiée)
      - [7.2.1 Quand une nouvelle version est disponible](#721-quand-une-nouvelle-version-est-disponible)
      - [7.2.2 En cas de problème](#722-en-cas-de-problème)

---

## 1. Procédures opérationnelles

### 1.1 Démarrage du système

#### 1.1.1 Allumage
1. **Démarrer le récepteur en premier :**
   - Connecter la batterie au récepteur (ESP32 + drone)
   - Attendre 3 secondes (voyant LED stable)

2. **Démarrer l'émetteur :**
   - Connecter la batterie à l'émetteur (manette avec joysticks)
   - La liaison radio s'établit automatiquement

3. **Vérification de la connexion :**
   - LED verte fixe = connexion établie
   - LED rouge clignotante = pas de connexion

### 1.2 Utilisation normale

#### 1.2.1 Contrôles de base
- **Joystick gauche (J1) :** Contrôle principal de vol
  - X (gauche/droite) : Direction
  - Y (avant/arrière) : Vitesse
  - Bouton : Arrêt d'urgence (maintenir enfoncé)

- **Joystick droit (J2) :** Contrôles auxiliaires
  - X/Y : Servomoteurs (si équipé)
  - Bouton : Fonction spéciale

#### 1.2.2 Fonctionnement normal
- Portée maximum : 100m en extérieur, 30m en intérieur
- Les moteurs s'arrêtent automatiquement si perte de signal
- Autonomie typique : 15-20 minutes selon la batterie

### 1.3 Arrêt du système

#### 1.3.1 Arrêt normal
1. **Arrêter les moteurs :** Centrer tous les joysticks
2. **Éteindre l'émetteur :** Débrancher la batterie émetteur
3. **Éteindre le récepteur :** Débrancher la batterie récepteur

#### 1.3.2 Arrêt d'urgence
- **Bouton d'urgence :** Maintenir enfoncé le bouton du joystick J1
- **Perte de signal :** Les moteurs s'arrêtent automatiquement après 200ms

## 2. Vue d'ensemble du système

### 2.1 Description du produit logiciel
Le système de contrôle Ornithoptère est un logiciel de commande à distance pour drone ornithoptère utilisant des microcontrôleurs ESP32. Le système permet le pilotage via des joysticks avec une interface de supervision en temps réel.

### 2.2 Architecture système
Le système est composé de deux modules principaux :
- **Module Émetteur** : Interface de pilotage avec joysticks
- **Module Récepteur** : Contrôle des moteurs et servomoteurs du drone

### 2.3 Contexte opérationnel client
Le système fonctionne dans l'environnement de production :
- **Environnement de Production** : ESP32 avec modules NRF24L01 pour communication radio 2.4GHz

## 3. Caractéristiques quantitatives du système

### 3.1 Données de performance CPU et Mémoire

#### 3.1.1 ESP32 (Environnement de production)
**Utilisation CPU :**
- Émetteur : ~15-25% (lecture joysticks + transmission NRF24L01)
- Récepteur : ~20-30% (réception NRF24L01 + contrôle PWM moteurs)
- Fréquence processeur : 240 MHz (dual-core)

**Utilisation Mémoire :**
- RAM totale ESP32 : 520 KB
- Utilisation émetteur : ~45-60 KB (stack + objets Python)
- Utilisation récepteur : ~50-70 KB (stack + objets Python + buffers PWM)
- Mémoire Flash : ~1.2 MB pour MicroPython + code utilisateur

### 3.2 Volume des données traitées

#### 3.2.1 Communication radio (NRF24L01)
- **Fréquence d'envoi** : 10 Hz (100ms entre paquets)
- **Taille des paquets** : 32 bytes maximum
- **Format de données** : JSON encodé UTF-8
- **Débit effectif** : ~320 bytes/seconde par direction

**Structure des données transmises :**
```json
{
  "J1": [x_value, y_value, button_state],  // Joystick 1
  "J2": [x_value, y_value, button_state]   // Joystick 2
}
```


#### 3.2.2 Volumes par période

**Quotidien :**
- Durée moyenne de vol : 10 minutes
- Données transmises : ~192 KB/jour
- Données reçues (ACK) : ~19.2 KB/jour

**Hebdomadaire :**
- Sessions de vol : ~5 sessions/semaine
- Volume total : ~1.34 MB/semaine

**Mensuel :**
- Volume de données : ~5.76 MB/mois
- Logs système : ~2-3 MB/mois

### 3.3 Performances temps réel
- **Latence de communication** : < 50ms (émetteur → récepteur)
- **Fréquence de rafraîchissement interface** : 20 Hz (50ms)
- **Temps de réponse moteurs** : < 10ms après réception commande
- **Délai de démarrage système** : < 3 secondes

## 4. Description des processus et interactions

### 4.1 Processus Émetteur (`emetteur_esp32.py`)

#### 4.1.1 Responsabilités
- Lecture des valeurs analogiques des joysticks (ADC)
- Traitement et normalisation des données (-512 à +512)
- Encodage JSON et transmission NRF24L01
- Gestion des états des boutons (toggle et momentané)

#### 4.1.2 Interactions externes
- **Entrées** : 2 joysticks analogiques (6 pins ADC), 2 boutons digitaux
- **Sorties** : Signaux radio NRF24L01 (SPI)

#### 4.1.3 Flux de données
```
Joysticks → ADC → Normalisation → JSON → NRF24L01 → Antenne
```

### 4.2 Processus Récepteur (`recepteur_esp32.py`)

#### 4.2.1 Responsabilités
- Réception et décodage des paquets NRF24L01
- Validation et parsing JSON
- Génération signaux PWM pour moteurs/servos
- Supervision état système

#### 4.2.2 Interactions externes
- **Entrées** : Signaux radio NRF24L01 (SPI)
- **Sorties** : 2 moteurs PWM, 2 servomoteurs PWM

#### 4.2.3 Flux de données
```
Antenne → NRF24L01 → JSON → Parsing → Commandes PWM → Moteurs/Servos
```

### 4.3 Communication Inter-Processus

#### 4.3.1 Mode Production (ESP32)
```
ESP32 Émetteur ←→ NRF24L01 Radio ←→ ESP32 Récepteur
     ↑                                      ↓
Joysticks physiques                 Moteurs physiques
```

## 5. Dépannage et diagnostic

### 5.1 Problèmes de communication
**Symptôme :** Pas de réception de données
- Vérifier canal radio (même valeur émetteur/récepteur)
- Contrôler alimentation NRF24L01 (3.3V strict)
- Vérifier câblage SPI

**Symptôme :** Données corrompues
- Réduire puissance transmission si interférences
- Changer de canal radio
- Vérifier stabilité alimentation

### 5.2 Problèmes de performance
**Symptôme :** Latence élevée
- Vérifier charge CPU (monitoring système)
- Optimiser fréquence d'envoi
- Réduire taille des paquets JSON

**Symptôme :** Perte de paquets
- Augmenter délai entre transmissions
- Vérifier qualité signal radio
- Contrôler stabilité hardware

## 6. Sécurité et limites

### 6.1 Limites opérationnelles
- **Portée radio** : ~100m en extérieur, ~30m en intérieur
- **Autonomie** : Dépendante de la batterie ESP32
- **Environnement** : Température -10°C à +70°C
- **Interférences** : Éviter proximité WiFi 2.4GHz

### 6.2 Procédures de sécurité
- **Failsafe** : Arrêt automatique des moteurs si perte communication
- **Validation données** : Contrôle intégrité paquets JSON
- **Limites physiques** : Saturation PWM à 100%

## 7. Mises à jour

### 7.1 Notification des nouvelles versions

#### 7.1.1 Recevoir les notifications automatiquement
1. **Accéder au site du projet** : [Lien vers le repository GitHub]
2. **Cliquer sur "Watch"** (en haut à droite)
3. **Sélectionner "Custom"**
4. **Cocher uniquement "Releases"**
5. **Confirmer**

Vous recevrez désormais un email à chaque nouvelle version disponible.

### 7.2 Procédure de mise à jour simplifiée

#### 7.2.1 Quand une nouvelle version est disponible
1. **Télécharger la nouvelle version** depuis la page "Releases" du projet
2. **Extraire les fichiers** sur votre ordinateur  
3. **Connecter vos ESP32** (émetteur et récepteur)
4. **Lancer la mise à jour automatique :**
   ```
   double-cliquer sur "mise-a-jour.bat" (Windows)
   ou
   ./mise-a-jour.sh (Linux/Mac)
   ```
5. **Suivre les instructions** affichées à l'écran
6. **Tester le fonctionnement** : allumer émetteur puis récepteur

#### 7.2.2 En cas de problème
- **Rollback automatique** : Le système garde une copie de l'ancienne version
- **Restauration** : Lancer `restaurer-version-precedente.bat/.sh`
- **Support** : Contacter le support technique avec le numéro de version

**⚠️ Important :** N'utilisez que les versions officielles marquées "Release". Les autres versions sont réservées au développement.

---
